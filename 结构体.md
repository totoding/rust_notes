# Rust 结构体详细教程

## 1. 什么是结构体？

结构体（struct）是一种自定义数据类型，允许你将多个相关的值组合在一起形成一个有意义的组合。结构体类似于其他语言中的对象或记录。

## 2. 结构体的三种类型

### 2.1 命名字段结构体（Named Field Struct）

这是最常用的结构体类型，每个字段都有名称和类型。

```rust
// 定义结构体
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    // 创建结构体实例
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // 访问字段
    println!("用户名: {}", user1.username);
    println!("邮箱: {}", user1.email);
}
```

### 2.2 元组结构体（Tuple Struct）

元组结构体没有字段名，只有字段类型，通过位置访问字段。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

    // 通过索引访问
    println!("红色分量: {}", black.0);
    println!("X坐标: {}", origin.0);
}
```

### 2.3 单元结构体（Unit Struct）

没有任何字段的结构体，通常用于实现 trait 而不需要存储数据。

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

## 3. 结构体的高级特性

### 3.1 可变性

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut rect = Rectangle {
        width: 30,
        height: 50,
    };

    // 修改字段值
    rect.width = 40;
    println!("宽度: {}", rect.width);
}
```

### 3.2 字段初始化简写

当变量名与字段名相同时，可以使用简写语法：

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,           // 等同于 email: email,
        username,        // 等同于 username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

### 3.3 结构体更新语法

使用现有实例创建新实例时，可以使用更新语法：

```rust
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1  // 使用 user1 的其他字段值
    };
}
```

## 4. 方法和关联函数

### 4.1 实现方法

使用 `impl` 块为结构体定义方法：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 方法（需要 &self 参数）
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    // 可变方法
    fn double_size(&mut self) {
        self.width *= 2;
        self.height *= 2;
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };

    println!("面积: {}", rect1.area());
    println!("rect1 能容纳 rect2: {}", rect1.can_hold(&rect2));
}
```

### 4.2 关联函数

不以 `self` 作为参数的函数，通常用作构造函数：

```rust
impl Rectangle {
    // 关联函数
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect = Rectangle::new(30, 50);
    let square = Rectangle::square(20);
}
```

## 5. 派生 trait

使用 `#[derive]` 属性自动实现常用 trait：

```rust
#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1.clone();

    println!("p1: {:?}", p1);      // Debug trait
    println!("p1 == p2: {}", p1 == p2);  // PartialEq trait
}
```

## 6. 实际应用示例

让我们创建一个更复杂的例子，展示结构体的实际应用：

```rust
#[derive(Debug)]
struct Book {
    title: String,
    author: String,
    pages: u32,
    available: bool,
}

impl Book {
    fn new(title: String, author: String, pages: u32) -> Book {
        Book {
            title,
            author,
            pages,
            available: true,
        }
    }

    fn borrow(&mut self) -> Result<(), String> {
        if self.available {
            self.available = false;
            Ok(())
        } else {
            Err("书籍已被借出".to_string())
        }
    }

    fn return_book(&mut self) {
        self.available = true;
    }

    fn info(&self) -> String {
        format!("《{}》 - {} ({} 页) - {}",
            self.title,
            self.author,
            self.pages,
            if self.available { "可借阅" } else { "已借出" }
        )
    }
}

#[derive(Debug)]
struct Library {
    books: Vec<Book>,
    name: String,
}

impl Library {
    fn new(name: String) -> Library {
        Library {
            books: Vec::new(),
            name,
        }
    }

    fn add_book(&mut self, book: Book) {
        self.books.push(book);
    }

    fn find_book(&mut self, title: &str) -> Option<&mut Book> {
        self.books.iter_mut().find(|book| book.title == title)
    }

    fn list_books(&self) {
        println!("{}图书馆藏书:", self.name);
        for book in &self.books {
            println!("  {}", book.info());
        }
    }
}

fn main() {
    let mut library = Library::new("城市".to_string());

    let book1 = Book::new(
        "Rust程序设计语言".to_string(),
        "Steve Klabnik".to_string(),
        500
    );

    let book2 = Book::new(
        "深入理解计算机系统".to_string(),
        "Randal Bryant".to_string(),
        800
    );

    library.add_book(book1);
    library.add_book(book2);

    library.list_books();

    // 借书
    if let Some(book) = library.find_book("Rust程序设计语言") {
        match book.borrow() {
            Ok(()) => println!("成功借阅《{}》", book.title),
            Err(e) => println!("借阅失败: {}", e),
        }
    }

    library.list_books();
}
```

## 7. 重要概念总结

### 7.1 所有权和借用

- 结构体拥有其所有字段的数据
- 当结构体离开作用域时，所有字段都会被清理
- 可以借用结构体的字段而不移动整个结构体

### 7.2 生命周期

当结构体包含引用时，需要指定生命周期参数：

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    println!("{}", i.part);
}
```

## 8. 最佳实践

1. **合理命名**: 使用清晰、描述性的字段和方法名
2. **封装**: 将相关数据和操作组织在一起
3. **不可变性**: 优先使用不可变结构体，只在必要时使用 `mut`
4. **派生 trait**: 适当使用 `#[derive]` 减少样板代码
5. **错误处理**: 在方法中适当使用 `Result` 类型处理错误

通过这个教程，你应该对Rust结构体有了全面的了解。建议多练习，逐步掌握这些概念！