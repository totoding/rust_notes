
### 变量 常量 基本类型

#### 变量 let
```
  let a = 1; // 变量默认不可变
  a = 2; // ❌ cannot mutate immutable variable `a`
  let a = 2; // ✔ 变量遮蔽

  let str = " ";
  let str = str.len();  // ✔ 变量遮蔽可改变类型

  let mut b: i32 = 3 // 使用 mut 后 变量b 可变
  b = 4; // ✔ 
  b = "5" // ❌ 类型不可变
```
#### 常量 const  
- 编译时确定
- 不可变
- 可以在任何作用域中声明
- 必须标注类型

#### 静态变量 static
- 全局变量
- 整个程序生命周期
- 默认不可变
- 可以是可变的（需要 unsafe）


```rust
static HELLO: &str = "Hello, world!";
static mut COUNTER: usize = 0;

// 访问可变静态变量需要 unsafe
unsafe {
    COUNTER += 1;
    println!("{}", COUNTER);
}
```

#### let vs const vs static

| 特性 | let | const | static |
|------|-----|-------|--------|
| 可变性 | 可变/不可变 | 始终不可变 | 默认不可变 |
| 作用域 | 块作用域 | 任何作用域 | 全局作用域 |
| 计算时机 | 运行时 | 编译时 | 编译时 |
| 内存位置 | 栈 | 内联 | 静态内存 |

---

#### 整数类型

##### 有符号整数 (Signed Integers)
- `i8`:   8位，范围: -128 到 127
- `i16`:  16位，范围: -32,768 到 32,767
- `i32`:  32位，范围: -2,147,483,648 到 2,147,483,647 (默认整数类型)
- `i64`:  64位，范围: -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
- `i128`: 128位，范围: -(2^127) 到 2^127-1
- `isize`: 架构相关大小 (32位系统上为32位，64位系统上为64位)

##### 无符号整数 (Unsigned Integers)
- `u8`:   8位，范围: 0 到 255
- `u16`:  16位，范围: 0 到 65,535
- `u32`:  32位，范围: 0 到 4,294,967,295
- `u64`:  64位，范围: 0 到 18,446,744,073,709,551,615
- `u128`: 128位，范围: 0 到 2^128-1
- `usize`: 架构相关大小，通常用于索引

##### 数字字面量表示法
```rust
let decimal = 98_222;        // 十进制，可以用下划线分隔
let hex = 0xff;              // 十六进制
let octal = 0o77;            // 八进制
let binary = 0b1111_0000;    // 二进制
let byte = b'A';             // 字节字面量 (仅限 u8)
```


#### 浮点数类型  f32 f64  
##### 特殊值  
```rust
let infinity = f64::INFINITY;
let neg_infinity = f64::NEG_INFINITY;
let nan =f64::NAN;
```
#### 布尔类型 bool
bool true | false  

#### 字符类型 char  
`char` 类型表示单个 Unicode 标量值 大小4字节 单引号包围 支持所有Unicode字符  

#### 字符串   
##### 字符串字面量 &str  
- 不可变引用  
- 储存在程序的二进制文件里  
- 编译时已知大小  
```rust
let s = "Hello World";
```
##### String 类型  
- 可变,可增长的字符串  
- 储存在堆上  
- URF-8 编码  

#### 元组类型 多个不同类型的值组合成一个复合类型
- 固定长度  
- 包含不同类型 
- 用圆括号和逗号定义  

#### 单元类型 空的元组  
```rust
let unit: () = ();  // 空元组，称为"单元类型"
```  
#### 嵌套元组  
```rust
let nested = ((1, 2), (3, 4));
let first_tuple = nested.0;     // (1, 2)
let first_element = nested.0.0; // 1
```  

#### 数组 相同类型元素的固定大小集合
- 固定长度
- 所有元素类型相同
- 存储在栈上

### 类型转换  
#### 显式转换 (as) 
```rust
let x = 42i32;
let y = x as f64;  // i32 转 f64
let z = x as u8;   // i32 转 u8 (可能截断)
```  
 转 u8 (可能截断)  

#### TryFrom 和 TryInto (可能失败的转换)
```rust
use std::convert::TryFrom;

let big_num = 300i32;
match u8::try_from(big_num) {
    Ok(small_num) => println!("转换成功: {}", small_num),
    Err(e) => println!("转换失败: {}", e),
}
```  


#### 最佳实践

##### 1. 选择合适的整数类型
- 默认使用 `i32`（性能最好）
- 需要特定范围时选择合适的类型
- 数组索引使用 `usize`

##### 2. 浮点数精度
- 默认使用 `f64`（精度更高）
- 性能敏感且精度要求不高时使用 `f32`
- 不要直接比较浮点数相等

##### 3. 字符串选择
- 只读字符串使用 `&str`
- 需要修改或拥有所有权时使用 `String`
- 字符串字面量默认是 `&str`

##### 4. 数组 vs 向量
- 编译时已知固定大小使用数组
- 需要动态大小使用 `Vec<T>`

##### 5. 类型转换
- 优先使用 `From`/`Into` trait
- 可能失败的转换使用 `TryFrom`/`TryInto`
- 避免使用 `as` 进行可能失败的转换

##### 6. 常量命名
- 常量和静态变量使用 `SCREAMING_SNAKE_CASE`
- 优先使用 `const` 而不是 `static`

##### 7. 类型标注
- 通常依赖类型推断
- 在不明确或需要特定类型时显式标注