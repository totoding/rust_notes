# Rust 枚举与 Match 详细教程

## 1. 枚举基础概念

### 什么是枚举？
枚举（Enum）是一种数据类型，它允许你定义一个类型的所有可能的值。在 Rust 中，枚举是一等公民，非常强大且灵活。

### 基本语法
```rust
enum 枚举名 {
    变体1,
    变体2,
    变体3,
}
```

## 2. 简单枚举

### 2.1 最基础的枚举
```rust
enum Direction {
    North,
    South,
    East,
    West,
}

fn main() {
    let dir = Direction::North;
    println!("选择了方向: {:?}", dir); // 需要 #[derive(Debug)]
}

// 完整版本
#[derive(Debug)]
enum Direction {
    North,
    South,
    East,
    West,
}
```

### 2.2 枚举方法
```rust
#[derive(Debug)]
enum Direction {
    North,
    South,
    East,
    West,
}

impl Direction {
    // 关联函数
    fn all() -> Vec<Direction> {
        vec![
            Direction::North,
            Direction::South,
            Direction::East,
            Direction::West,
        ]
    }
    
    // 方法
    fn is_horizontal(&self) -> bool {
        matches!(self, Direction::East | Direction::West)
    }
    
    fn opposite(&self) -> Direction {
        match self {
            Direction::North => Direction::South,
            Direction::South => Direction::North,
            Direction::East => Direction::West,
            Direction::West => Direction::East,
        }
    }
}
```

## 3. 带数据的枚举

### 3.1 每个变体携带不同类型的数据
```rust
#[derive(Debug)]
enum Message {
    Quit,                       // 无数据
    Move { x: i32, y: i32 },   // 结构体式
    Write(String),              // 元组式
    ChangeColor(i32, i32, i32), // 多个值的元组
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Move { x: 10, y: 20 };
    let msg3 = Message::Write(String::from("Hello"));
    let msg4 = Message::ChangeColor(255, 0, 0);
    
    println!("{:?}", msg1);
    println!("{:?}", msg2);
    println!("{:?}", msg3);
    println!("{:?}", msg4);
}
```

### 3.2 复杂数据类型
```rust
#[derive(Debug)]
enum WebEvent {
    PageLoad,
    PageUnload,
    KeyPress(char),
    Paste(String),
    Click { x: i64, y: i64 },
    MouseMove { x: i64, y: i64 },
}

#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
}

#[derive(Debug)]
enum Shape {
    Circle(Point, f64),           // 圆心和半径
    Rectangle(Point, Point),      // 左上角和右下角
    Triangle(Point, Point, Point), // 三个顶点
}
```

## 4. Option 枚举详解

### 4.1 Option 的定义和用途
```rust
// Rust 标准库中的 Option 定义
enum Option<T> {
    None,
    Some(T),
}

fn main() {
    let some_number = Some(5);
    let some_string = Some("a string");
    let absent_number: Option<i32> = None;
    
    println!("{:?}", some_number);
    println!("{:?}", some_string);
    println!("{:?}", absent_number);
}
```

### 4.2 Option 常用方法
```rust
fn option_methods_demo() {
    let x = Some(5);
    let y: Option<i32> = None;
    
    // is_some() 和 is_none()
    println!("x.is_some(): {}", x.is_some()); // true
    println!("y.is_none(): {}", y.is_none()); // true
    
    // unwrap() - 危险，会 panic
    // let value = y.unwrap(); // 这会 panic!
    
    // unwrap_or() - 提供默认值
    let value = y.unwrap_or(0);
    println!("y.unwrap_or(0): {}", value); // 0
    
    // unwrap_or_else() - 使用闭包计算默认值
    let value = y.unwrap_or_else(|| 42);
    println!("y.unwrap_or_else(|| 42): {}", value); // 42
    
    // map() - 变换 Some 中的值
    let squared = x.map(|val| val * val);
    println!("x.map(|val| val * val): {:?}", squared); // Some(25)
    
    // and_then() - 链式操作
    let result = x.and_then(|val| Some(val * 2));
    println!("x.and_then(|val| Some(val * 2)): {:?}", result); // Some(10)
}
```

## 5. Result 枚举详解

### 5.1 Result 的定义和用途
```rust
// Rust 标准库中的 Result 定义
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("Cannot divide by zero!".to_string())
    } else {
        Ok(a / b)
    }
}

fn main() {
    let result1 = divide(10.0, 2.0);
    let result2 = divide(10.0, 0.0);
    
    println!("{:?}", result1); // Ok(5.0)
    println!("{:?}", result2); // Err("Cannot divide by zero!")
}
```

### 5.2 Result 错误处理
```rust
use std::fs::File;
use std::io::{self, Read};

fn read_file_contents(filename: &str) -> Result<String, io::Error> {
    let mut file = File::open(filename)?; // ? 操作符
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

fn result_handling_demo() {
    match read_file_contents("example.txt") {
        Ok(contents) => println!("File contents: {}", contents),
        Err(error) => println!("Error reading file: {}", error),
    }
    
    // 使用 unwrap_or_else 处理错误
    let contents = read_file_contents("example.txt")
        .unwrap_or_else(|_| "Default content".to_string());
    
    println!("Contents: {}", contents);
}
```

## 6. Match 表达式基础

### 6.1 基本 Match 语法
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {
    let coin = Coin::Quarter;
    println!("Value: {} cents", value_in_cents(coin));
}
```

### 6.2 Match 绑定值
```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    California,
    Texas,
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

### 6.3 Match 必须穷举所有可能
```rust
fn match_option(x: Option<i32>) -> i32 {
    match x {
        None => 0,
        Some(i) => i,
    }
}

// 使用占位符 _
fn match_with_catchall(x: Option<i32>) -> String {
    match x {
        Some(1) => "one".to_string(),
        Some(2) => "two".to_string(),
        Some(3) => "three".to_string(),
        _ => "something else".to_string(),
    }
}
```

## 7. 高级模式匹配

### 7.1 解构结构体和元组
```rust
struct Point {
    x: i32,
    y: i32,
}

enum Message {
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn pattern_matching_demo() {
    let p = Point { x: 0, y: 7 };
    
    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
    
    let msg = Message::ChangeColor(0, 160, 255);
    
    match msg {
        Message::Move { x, y } => {
            println!("Move in the x direction {} and in the y direction {}", x, y);
        },
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b);
        }
    }
}
```

### 7.2 嵌套的枚举和结构体
```rust
enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    ChangeColor(Color),
    Move { x: i32, y: i32 },
    Write(String),
}

fn nested_matching() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
    
    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b);
        },
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change the color to hue {}, saturation {}, and value {}", h, s, v);
        },
        _ => println!("Other message"),
    }
}
```

### 7.3 范围模式和多个模式
```rust
fn range_patterns(x: i32) {
    match x {
        1..=5 => println!("one through five"),
        6 | 7 | 8 => println!("six, seven, or eight"),
        9..=20 => println!("nine through twenty"),
        _ => println!("anything else"),
    }
}

fn char_patterns(x: char) {
    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
}
```

### 7.4 守卫条件（Match Guards）
```rust
fn match_guards_demo() {
    let num = Some(4);
    
    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }
    
    let x = Some(5);
    let y = 10;
    
    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }
}
```

## 8. if let 表达式

### 8.1 简化单一模式匹配
```rust
fn if_let_demo() {
    let some_value = Some(5);
    
    // 使用 match
    match some_value {
        Some(x) => println!("Got a value: {}", x),
        None => (),
    }
    
    // 使用 if let（更简洁）
    if let Some(x) = some_value {
        println!("Got a value: {}", x);
    }
    
    // if let 与 else
    if let Some(x) = some_value {
        println!("Got a value: {}", x);
    } else {
        println!("Got None");
    }
}
```

### 8.2 复杂的 if let 模式
```rust
enum Message {
    Hello { id: i32 },
    Goodbye,
}

fn complex_if_let() {
    let msg = Message::Hello { id: 5 };
    
    if let Message::Hello { id: id_variable @ 3..=7 } = msg {
        println!("Found an id in range: {}", id_variable);
    }
}
```

## 9. while let 循环

```rust
fn while_let_demo() {
    let mut stack = Vec::new();
    
    stack.push(1);
    stack.push(2);
    stack.push(3);
    
    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
    // 输出: 3, 2, 1
}
```

## 10. @ 绑定

```rust
enum Message {
    Hello { id: i32 },
}

fn at_bindings() {
    let msg = Message::Hello { id: 5 };
    
    match msg {
        Message::Hello { 
            id: id_variable @ 3..=7 
        } => println!("Found an id in range: {}", id_variable),
        Message::Hello { id: 10..=12 } => {
            println!("Found an id in another range");
        },
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
}
```

## 11. 实战示例

### 11.1 状态机
```rust
#[derive(Debug)]
enum State {
    Idle,
    Processing { progress: u8 },
    Completed,
    Error(String),
}

struct Task {
    id: u32,
    state: State,
}

impl Task {
    fn new(id: u32) -> Self {
        Task {
            id,
            state: State::Idle,
        }
    }
    
    fn start(&mut self) {
        match self.state {
            State::Idle => {
                self.state = State::Processing { progress: 0 };
                println!("Task {} started", self.id);
            },
            _ => println!("Task {} cannot be started from current state", self.id),
        }
    }
    
    fn update_progress(&mut self, progress: u8) {
        match &mut self.state {
            State::Processing { progress: p } => {
                *p = progress;
                if progress >= 100 {
                    self.state = State::Completed;
                    println!("Task {} completed", self.id);
                }
            },
            _ => println!("Task {} is not in processing state", self.id),
        }
    }
    
    fn get_status(&self) -> String {
        match &self.state {
            State::Idle => "Waiting to start".to_string(),
            State::Processing { progress } => format!("{}% complete", progress),
            State::Completed => "Done".to_string(),
            State::Error(msg) => format!("Error: {}", msg),
        }
    }
}
```

### 11.2 表达式求值器
```rust
#[derive(Debug)]
enum Expr {
    Number(f64),
    Add(Box<Expr>, Box<Expr>),
    Subtract(Box<Expr>, Box<Expr>),
    Multiply(Box<Expr>, Box<Expr>),
    Divide(Box<Expr>, Box<Expr>),
}

fn eval(expr: &Expr) -> Result<f64, String> {
    match expr {
        Expr::Number(n) => Ok(*n),
        Expr::Add(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l + r)
        },
        Expr::Subtract(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l - r)
        },
        Expr::Multiply(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            Ok(l * r)
        },
        Expr::Divide(left, right) => {
            let l = eval(left)?;
            let r = eval(right)?;
            if r == 0.0 {
                Err("Division by zero".to_string())
            } else {
                Ok(l / r)
            }
        },
    }
}

fn expression_demo() {
    // (10 + 5) * 2
    let expr = Expr::Multiply(
        Box::new(Expr::Add(
            Box::new(Expr::Number(10.0)),
            Box::new(Expr::Number(5.0))
        )),
        Box::new(Expr::Number(2.0))
    );
    
    match eval(&expr) {
        Ok(result) => println!("Result: {}", result),
        Err(error) => println!("Error: {}", error),
    }
}
```

## 12. 最佳实践和常见模式

### 12.1 使用 matches! 宏进行简单匹配
```rust
fn matches_macro_demo() {
    let msg = Some(42);
    
    // 传统方式
    let is_some = match msg {
        Some(_) => true,
        None => false,
    };
    
    // 使用 matches! 宏
    let is_some = matches!(msg, Some(_));
    
    println!("Is some: {}", is_some);
}
```

### 12.2 错误处理模式
```rust
#[derive(Debug)]
enum AppError {
    IoError(std::io::Error),
    ParseError(std::num::ParseIntError),
    CustomError(String),
}

impl From<std::io::Error> for AppError {
    fn from(error: std::io::Error) -> Self {
        AppError::IoError(error)
    }
}

impl From<std::num::ParseIntError> for AppError {
    fn from(error: std::num::ParseIntError) -> Self {
        AppError::ParseError(error)
    }
}

fn process_file(filename: &str) -> Result<i32, AppError> {
    let contents = std::fs::read_to_string(filename)?;
    let number: i32 = contents.trim().parse()?;
    Ok(number * 2)
}
```

### 12.3 枚举作为状态管理
```rust
#[derive(Debug)]
enum ConnectionState {
    Disconnected,
    Connecting,
    Connected { session_id: String },
    Reconnecting { attempts: u32 },
}

struct Connection {
    state: ConnectionState,
}

impl Connection {
    fn new() -> Self {
        Connection {
            state: ConnectionState::Disconnected,
        }
    }
    
    fn connect(&mut self) -> Result<(), String> {
        match &self.state {
            ConnectionState::Disconnected => {
                self.state = ConnectionState::Connecting;
                // 模拟连接过程
                self.state = ConnectionState::Connected {
                    session_id: "abc123".to_string()
                };
                Ok(())
            },
            ConnectionState::Connected { .. } => {
                Err("Already connected".to_string())
            },
            _ => Err("Cannot connect from current state".to_string()),
        }
    }
    
    fn is_connected(&self) -> bool {
        matches!(self.state, ConnectionState::Connected { .. })
    }
}
```

## 总结

Rust 的枚举和模式匹配系统提供了强大而类型安全的方式来处理不同状态和数据变体。关键要点：

1. **枚举可以携带数据** - 使其比其他语言中的枚举更加强大
2. **Match 必须穷举所有情况** - 提供了编译时的安全保证
3. **Option 和 Result** - 是处理可能失败操作的标准方式
4. **模式匹配不仅限于 match** - if let, while let 等提供了更简洁的语法
5. **守卫条件和 @ 绑定** - 提供了更精确的模式控制

掌握这些概念将大大提高你编写安全、表达力强的 Rust 代码的能力。