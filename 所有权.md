# Rust 所有权、移动和引用详细教程

## 目录
1. [所有权基础概念](#1-所有权基础概念)
2. [移动语义详解](#2-移动语义详解)
3. [引用和借用](#3-引用和借用)
4. [生命周期](#4-生命周期)
5. [智能指针与所有权](#5-智能指针与所有权)
6. [实战示例和最佳实践](#6-实战示例和最佳实践)

## 1. 所有权基础概念

### 1.1 什么是所有权

所有权是 Rust 管理内存的核心机制，确保内存安全而无需垃圾回收器。

**所有权规则：**
1. Rust 中每个值都有一个所有者（owner）
2. 同时只能有一个所有者
3. 当所有者离开作用域时，值被丢弃（dropped）

```rust
fn main() {
    // s 是字符串字面值的所有者
    let s1 = "hello"; // 存储在程序的二进制文件中，不可变
    
    // s2 是 String 对象的所有者
    let s2 = String::from("hello"); // 存储在堆上，可变
    
    println!("s1: {}", s1);
    println!("s2: {}", s2);
    
    // 当 main 函数结束时，s1 和 s2 都会被清理
    // s1 只是指向静态内存的引用，无需特殊清理
    // s2 会调用 drop 函数释放堆内存
}
```

### 1.2 栈与堆的区别

```rust
fn stack_vs_heap() {
    // 栈数据 - 编译时大小已知
    let x = 5;        // i32，存储在栈上
    let y = true;     // bool，存储在栈上
    let z = 'A';      // char，存储在栈上
    
    // 堆数据 - 运行时大小可变
    let s = String::from("hello"); // String，内容存储在堆上
    let v = vec![1, 2, 3];         // Vec，内容存储在堆上
    
    println!("栈数据: {}, {}, {}", x, y, z);
    println!("堆数据: {}, {:?}", s, v);
    
    // 栈数据复制成本低
    let x2 = x; // 简单的位复制
    println!("x: {}, x2: {}", x, x2); // 两个都可以使用
    
    // 堆数据复制成本高，Rust 默认使用移动
    let s2 = s; // s 被移动到 s2
    // println!("{}", s); // 错误！s 已经无效
    println!("s2: {}", s2);
}
```

### 1.3 Copy trait 和 Drop trait

```rust
fn copy_vs_drop() {
    // 实现了 Copy trait 的类型
    let x = 5;
    let y = x;  // 复制，不是移动
    println!("x: {}, y: {}", x, y); // 两个都有效
    
    // 实现了 Drop trait 的类型（不能同时实现 Copy）
    let s1 = String::from("hello");
    let s2 = s1;  // 移动，不是复制
    // println!("{}", s1); // 错误！s1 已失效
    println!("s2: {}", s2);
    
    // 常见的 Copy 类型
    let a: i32 = 1;
    let b: f64 = 2.0;
    let c: bool = true;
    let d: char = 'A';
    let e: (i32, i32) = (1, 2);
    
    // 这些都是复制操作
    let a2 = a;
    let b2 = b;
    let c2 = c;
    let d2 = d;
    let e2 = e;
    
    println!("所有 Copy 类型都仍然有效: {}, {}, {}, {}, {:?}", 
             a, b, c, d, e);
}
```

### 1.4 所有权转移的时机

```rust
fn ownership_transfer() {
    // 1. 赋值时转移
    let s1 = String::from("hello");
    let s2 = s1;  // s1 -> s2
    
    // 2. 函数参数传递时转移
    fn takes_ownership(s: String) {
        println!("函数内: {}", s);
    } // s 在这里被 drop
    
    takes_ownership(s2); // s2 被移动到函数中
    // println!("{}", s2); // 错误！s2 已失效
    
    // 3. 函数返回时转移
    fn gives_ownership() -> String {
        String::from("world")
    }
    
    let s3 = gives_ownership(); // 所有权从函数转移到 s3
    println!("返回的字符串: {}", s3);
    
    // 4. 结构体字段赋值时转移
    struct Person {
        name: String,
        age: u32,
    }
    
    let name = String::from("Alice");
    let person = Person {
        name: name, // name 被移动到 person.name
        age: 30,
    };
    // println!("{}", name); // 错误！name 已失效
    println!("人员: {} - {}", person.name, person.age);
}
```

## 2. 移动语义详解

### 2.1 移动的本质

```rust
fn move_semantics_explained() {
    // String 的内部结构大致如下：
    // struct String {
    //     ptr: *mut u8,    // 指向堆内存的指针
    //     len: usize,      // 当前长度
    //     capacity: usize, // 容量
    // }
    
    let s1 = String::from("hello");
    println!("s1 地址: {:p}", s1.as_ptr());
    
    let s2 = s1; // 只复制栈上的数据（ptr, len, capacity），不复制堆数据
    println!("s2 地址: {:p}", s2.as_ptr()); // 相同的地址
    
    // s1 现在无效，避免了双重释放问题
    // println!("{}", s1); // 编译错误
    
    // 演示复制行为
    let x = 5;
    let y = x; // 栈上简单复制
    println!("x: {}, y: {}", x, y); // 都有效
}
```

### 2.2 深拷贝 vs 浅拷贝

```rust
fn clone_vs_move() {
    let s1 = String::from("hello");
    
    // 移动（浅拷贝指针，原变量失效）
    let s2 = s1;
    // println!("{}", s1); // 错误
    
    // 深拷贝
    let s3 = s2.clone(); // 创建新的堆内存
    println!("s2: {}", s2); // 仍然有效
    println!("s3: {}", s3); // 也有效
    println!("s2 地址: {:p}", s2.as_ptr());
    println!("s3 地址: {:p}", s3.as_ptr()); // 不同的地址
    
    // Vec 的例子
    let v1 = vec![1, 2, 3, 4, 5];
    let v2 = v1.clone(); // 深拷贝
    
    println!("v1: {:?}", v1);
    println!("v2: {:?}", v2);
    println!("v1 地址: {:p}", v1.as_ptr());
    println!("v2 地址: {:p}", v2.as_ptr()); // 不同地址
}
```

### 2.3 部分移动

```rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
    email: String,
}

fn partial_move() {
    let person = Person {
        name: String::from("Alice"),
        age: 30,
        email: String::from("alice@example.com"),
    };
    
    // 部分移动
    let name = person.name;  // 移动 name 字段
    let age = person.age;    // 复制 age 字段（Copy 类型）
    
    // println!("{:?}", person); // 错误！person.name 已被移动
    // println!("{}", person.name); // 错误！
    
    println!("age: {}", person.age);     // OK，u32 实现了 Copy
    println!("email: {}", person.email); // OK，email 未被移动
    
    // 但是不能使用整个结构体
    // let person2 = person; // 错误！部分字段已移动
    
    println!("移动的 name: {}", name);
    println!("复制的 age: {}", age);
}
```

### 2.4 集合中的移动

```rust
fn collection_moves() {
    // Vec 中的移动
    let mut vec = vec![
        String::from("hello"),
        String::from("world"),
        String::from("rust"),
    ];
    
    // 从 Vec 中移动元素
    let first = vec.remove(0); // 移动第一个元素
    println!("移动的元素: {}", first);
    println!("剩余元素: {:?}", vec);
    
    // 使用 pop 移动最后一个元素
    if let Some(last) = vec.pop() {
        println!("弹出的元素: {}", last);
    }
    
    // 迭代器中的移动
    let strings = vec![String::from("a"), String::from("b"), String::from("c")];
    
    // into_iter() 会移动所有权
    for s in strings.into_iter() {
        println!("拥有: {}", s);
    }
    // println!("{:?}", strings); // 错误！已被移动
    
    // HashMap 中的移动
    use std::collections::HashMap;
    
    let mut map = HashMap::new();
    let key = String::from("key1");
    let value = String::from("value1");
    
    map.insert(key, value); // key 和 value 都被移动
    // println!("{}, {}", key, value); // 错误！
    
    if let Some(v) = map.get("key1") {
        println!("从 map 获取: {}", v);
    }
}
```

## 3. 引用和借用

### 3.1 不可变引用

```rust
fn immutable_references() {
    let s = String::from("hello");
    
    // 创建引用（借用）
    let r1 = &s;  // r1 是 s 的不可变引用
    let r2 = &s;  // 可以有多个不可变引用
    
    println!("原始字符串: {}", s);
    println!("引用1: {}", r1);
    println!("引用2: {}", r2);
    
    // 引用不拥有数据
    println!("s 的长度: {}", s.len());
    println!("r1 的长度: {}", r1.len());
    
    // 函数参数使用引用
    fn calculate_length(s: &String) -> usize {
        s.len() // s 是引用，不会获得所有权
    } // s 离开作用域，但不会 drop，因为它不拥有数据
    
    let len = calculate_length(&s);
    println!("长度: {}", len);
    println!("s 仍然有效: {}", s); // s 仍然有效
}
```

### 3.2 可变引用

```rust
fn mutable_references() {
    let mut s = String::from("hello");
    
    // 创建可变引用
    {
        let r1 = &mut s;
        r1.push_str(", world");
        println!("可变引用修改后: {}", r1);
    } // r1 离开作用域
    
    println!("原始字符串: {}", s);
    
    // 函数使用可变引用
    fn append_exclamation(s: &mut String) {
        s.push('!');
    }
    
    append_exclamation(&mut s);
    println!("添加感叹号后: {}", s);
    
    // 可变引用的限制
    let r1 = &mut s;
    // let r2 = &mut s; // 错误！不能有多个可变引用
    r1.push_str(" Amazing!");
    println!("r1: {}", r1);
    
    // r1 使用结束后，可以创建新的引用
    let r2 = &mut s;
    r2.push_str(" Rust!");
    println!("r2: {}", r2);
}
```

### 3.3 引用规则详解

```rust
fn reference_rules() {
    let mut s = String::from("hello");
    
    // 规则1：可以有任意数量的不可变引用
    let r1 = &s;
    let r2 = &s;
    let r3 = &s;
    
    println!("不可变引用: {}, {}, {}", r1, r2, r3);
    
    // 规则2：只能有一个可变引用
    // let r4 = &mut s; // 错误！不能同时有可变和不可变引用
    
    // 不可变引用的作用域结束
    println!("最后使用不可变引用: {}", r3);
    
    // 现在可以创建可变引用
    let r4 = &mut s;
    r4.push_str(" world");
    println!("可变引用: {}", r4);
    
    // 演示引用作用域
    {
        let r5 = &mut s;
        r5.push('!');
        // r5 在此作用域结束
    }
    
    // 可以创建新的引用
    let r6 = &s;
    println!("新的不可变引用: {}", r6);
}
```

### 3.4 悬垂引用的预防

```rust
fn dangling_references() {
    // 编译器防止悬垂引用
    
    // 错误示例（无法编译）
    /*
    fn dangle() -> &String {
        let s = String::from("hello");
        &s  // 返回 s 的引用，但 s 即将被 drop
    } // s 离开作用域并被 drop，但引用仍指向它
    */
    
    // 正确做法1：返回所有权
    fn no_dangle() -> String {
        let s = String::from("hello");
        s  // 所有权被移动，没有问题
    }
    
    let result = no_dangle();
    println!("返回所有权: {}", result);
    
    // 正确做法2：使用生命周期参数
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    
    let string1 = String::from("long string");
    let string2 = String::from("short");
    let result = longest(&string1, &string2);
    println!("最长的字符串: {}", result);
}
```

### 3.5 解引用

```rust
fn dereferencing() {
    let x = 5;
    let y = &x;  // y 是 x 的引用
    
    println!("x = {}", x);
    println!("y = {}", y);   // 自动解引用打印
    println!("*y = {}", *y); // 手动解引用
    
    // assert_eq!(5, y);   // 错误！类型不匹配
    assert_eq!(5, *y);     // 正确
    
    // 字符串解引用
    let s = String::from("hello");
    let r = &s;
    
    println!("s.len() = {}", s.len());
    println!("r.len() = {}", r.len());    // 自动解引用
    println!("(*r).len() = {}", (*r).len()); // 手动解引用
    
    // 可变引用解引用
    let mut x = 5;
    let y = &mut x;
    *y = 10;  // 通过可变引用修改值
    
    println!("修改后的 x: {}", x);
    
    // 多级引用
    let x = 5;
    let y = &x;
    let z = &y;
    
    println!("x = {}", x);
    println!("*y = {}", *y);
    println!("**z = {}", **z); // 两次解引用
}
```

## 4. 生命周期

### 4.1 生命周期基础

```rust
fn lifetime_basics() {
    // 生命周期是引用有效的作用域
    
    let r;                // ---------+-- 'a
                         //          |
    {                    //          |
        let x = 5;       // -+-- 'b  |
        r = &x;          //  |       |
    }                    // -+       |
                         //          |
    // println!("r: {}", r); // 错误！'b 比 'a 短
    
    // 正确的例子
    let x = 5;            // ----------+-- 'a
    let r = &x;          // --+-- 'b  |
                         //   |       |
    println!("r: {}", r); //   |       |
                         // --+       |
                         // ----------+
}
```

### 4.2 函数中的生命周期

```rust
// 生命周期注解
fn lifetime_in_functions() {
    // 不需要显式生命周期注解（生命周期省略规则）
    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();
        
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }
        
        &s[..]
    }
    
    let sentence = String::from("hello world");
    let word = first_word(&sentence);
    println!("第一个单词: {}", word);
    
    // 需要显式生命周期注解
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    
    let string1 = String::from("abcd");
    let string2 = "xyz";
    
    let result = longest(string1.as_str(), string2);
    println!("较长的字符串: {}", result);
    
    // 生命周期约束
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
        println!("在内部作用域: {}", result);
    }
    // println!("在外部作用域: {}", result); // 错误！string2 的生命周期太短
}
```

### 4.3 结构体中的生命周期

```rust
// 包含引用的结构体需要生命周期注解
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    // 方法中的生命周期
    fn level(&self) -> i32 {
        3
    }
    
    // 有多个生命周期参数的方法
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("注意！{}", announcement);
        self.part
    }
}

fn lifetime_in_structs() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    
    println!("重要摘录: {}", i.part);
    println!("级别: {}", i.level());
    
    let result = i.announce_and_return_part("这是重要内容！");
    println!("返回的部分: {}", result);
}
```

### 4.4 生命周期省略规则

```rust
fn lifetime_elision_rules() {
    // 规则1：每个引用参数都有自己的生命周期参数
    // fn foo(x: &str) -> &str  实际上是
    // fn foo<'a>(x: &'a str) -> &'a str
    
    // 规则2：如果只有一个输入生命周期参数，那个生命周期被赋予所有输出生命周期参数
    fn single_input(s: &str) -> &str {
        s
    }
    
    // 规则3：如果方法有多个输入生命周期参数，但其中一个是 &self 或 &mut self，
    // 那么 self 的生命周期被赋予所有输出生命周期参数
    
    struct Foo<'a> {
        x: &'a str,
    }
    
    impl<'a> Foo<'a> {
        fn get_x(&self) -> &str {  // 实际上是 fn get_x<'a>(&'a self) -> &'a str
            self.x
        }
    }
    
    let s = String::from("hello");
    let foo = Foo { x: &s };
    println!("Foo.x: {}", foo.get_x());
}
```

### 4.5 静态生命周期

```rust
fn static_lifetime() {
    // 'static 生命周期存在于整个程序执行期间
    let s: &'static str = "I have a static lifetime.";
    println!("静态字符串: {}", s);
    
    // 字符串字面值都有 'static 生命周期
    fn get_static() -> &'static str {
        "这是静态字符串"
    }
    
    println!("函数返回的静态字符串: {}", get_static());
    
    // 使用 Box::leak 创建静态引用（谨慎使用）
    fn create_static_string(s: String) -> &'static str {
        Box::leak(s.into_boxed_str())
    }
    
    let dynamic = String::from("动态字符串");
    let static_ref = create_static_string(dynamic);
    println!("泄露的静态引用: {}", static_ref);
    
    // 注意：Box::leak 会导致内存泄露，通常不建议使用
}
```

## 5. 智能指针与所有权

### 5.1 Box<T> - 堆分配

```rust
fn box_pointer() {
    // Box 提供堆分配
    let b = Box::new(5);
    println!("b = {}", b);
    
    // 递归类型需要 Box
    enum List {
        Cons(i32, Box<List>),
        Nil,
    }
    
    use List::{Cons, Nil};
    
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    
    fn print_list(list: &List) {
        match list {
            Cons(val, next) => {
                println!("值: {}", val);
                print_list(next);
            },
            Nil => println!("列表结束"),
        }
    }
    
    print_list(&list);
    
    // Box 的解引用
    let x = 5;
    let y = Box::new(x);
    
    assert_eq!(5, x);
    assert_eq!(5, *y); // 解引用 Box
}
```

### 5.2 Rc<T> - 引用计数

```rust
use std::rc::Rc;

fn reference_counting() {
    // Rc 允许多个所有者
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("创建 a 后的引用计数: {}", Rc::strong_count(&a));
    
    let b = Cons(3, Rc::clone(&a));
    println!("创建 b 后的引用计数: {}", Rc::strong_count(&a));
    
    {
        let c = Cons(4, Rc::clone(&a));
        println!("创建 c 后的引用计数: {}", Rc::strong_count(&a));
    }
    
    println!("c 离开作用域后的引用计数: {}", Rc::strong_count(&a));
    
    enum List {
        Cons(i32, Rc<List>),
        Nil,
    }
    
    use List::{Cons, Nil};
    
    // Rc 只能用于不可变引用
    let shared_list = Rc::new(Cons(1, Rc::new(Cons(2, Rc::new(Nil)))));
    let list1 = Cons(10, Rc::clone(&shared_list));
    let list2 = Cons(20, Rc::clone(&shared_list));
    
    // 不能修改 Rc 内的数据
    // shared_list.push(3); // 错误！Rc 是不可变的
}
```

### 5.3 RefCell<T> - 内部可变性

```rust
use std::cell::RefCell;
use std::rc::Rc;

fn interior_mutability() {
    // RefCell 提供运行时借用检查
    let x = RefCell::new(5);
    
    // 不可变借用
    let borrowed = x.borrow();
    println!("借用的值: {}", *borrowed);
    drop(borrowed); // 释放借用
    
    // 可变借用
    {
        let mut borrowed_mut = x.borrow_mut();
        *borrowed_mut += 10;
    }
    
    println!("修改后的值: {}", x.borrow());
    
    // 组合 Rc 和 RefCell
    #[derive(Debug)]
    enum List {
        Cons(Rc<RefCell<i32>>, Rc<List>),
        Nil,
    }
    
    use List::{Cons, Nil};
    
    let value = Rc::new(RefCell::new(5));
    
    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));
    
    *value.borrow_mut() += 10;
    
    println!("a 修改后: {:?}", a);
    println!("b 修改后: {:?}", b);
    println!("c 修改后: {:?}", c);
}
```

## 6. 实战示例和最佳实践

### 6.1 所有权模式

```rust
fn ownership_patterns() {
    // 模式1：获取所有权并返回
    fn process_and_return(mut s: String) -> String {
        s.push_str(" processed");
        s
    }
    
    // 模式2：借用并返回新值
    fn process_borrowed(s: &str) -> String {
        format!("{} processed", s)
    }
    
    // 模式3：就地修改
    fn process_in_place(s: &mut String) {
        s.push_str(" processed");
    }
    
    let original = String::from("hello");
    
    // 使用模式1
    let result1 = process_and_return(original); // original 被移动
    // println!("{}", original); // 错误！
    println!("模式1结果: {}", result1);
    
    // 使用模式2
    let original2 = String::from("hello");
    let result2 = process_borrowed(&original2); // 借用
    println!("模式2原始: {}", original2); // 仍然有效
    println!("模式2结果: {}", result2);
    
    // 使用模式3
    let mut original3 = String::from("hello");
    process_in_place(&mut original3); // 可变借用
    println!("模式3结果: {}", original3);
}
```

### 6.2 错误处理与所有权

```rust
fn error_handling_ownership() {
    use std::fs;
    use std::io;
    
    // 所有权友好的错误处理
    fn read_file_contents(filename: &str) -> Result<String, io::Error> {
        // 返回 String 所有权，不是借用
        fs::read_to_string(filename)
    }
    
    // 处理 Option 中的所有权
    fn get_first_word(s: Option<String>) -> Option<String> {
        s.map(|text| {
            text.split_whitespace()
                .next()
                .unwrap_or("")
                .to_string()
        })
    }
    
    // 使用 ? 操作符和所有权
    fn process_file(filename: &str) -> Result<usize, io::Error> {
        let contents = fs::read_to_string(filename)?; // 获得所有权
        Ok(contents.len()) // 可以消费 contents
    }
    
    // 演示使用
    let text = Some(String::from("hello world rust"));
    if let Some(first) = get_first_word(text) {
        println!("第一个单词: {}", first);
    }
    
    // 错误链和所有权
    #[derive(Debug)]
    enum MyError {
        Io(io::Error),
        Parse(String),
    }
    
    impl From<io::Error> for MyError {
        fn from(err: io::Error) -> Self {
            MyError::Io(err)
        }
    }
    
    fn complex_operation(filename: &str) -> Result<i32, MyError> {
        let contents = fs::read_to_string(filename)?; // io::Error -> MyError
        contents.trim()
            .parse::<i32>()
            .map_err(|_| MyError::Parse(contents)) // 移动 contents 到错误中
    }
    
    // 注意：上面的代码中 contents 被移动了，所以可以这样做
}
```

### 6.3 集合操作与所有权

```rust
fn collections_ownership() {
    use std::collections::HashMap;
    
    // Vec 操作中的所有权
    let mut names = vec![
        String::from("Alice"),
        String::from("Bob"),
        String::from("Charlie"),
    ];
    
    // 移动元素
    let first_name = names.remove(0);
    println!("移动的名字: {}", first_name);
    println!("剩余名字: {:?}", names);
    
    // 不移动的访问
    if let Some(second) = names.get(0) {
        println!("第二个名字（借用）: {}", second);
    }
    
    // 迭代器与所有权
    let numbers = vec![1, 2, 3, 4, 5];
    
    // iter() - 借用
    for num in numbers.iter() {
        println!("借用: {}", num);
    }
    println!("numbers 仍然有效: {:?}", numbers);
    
    // into_iter() - 移动
    for num in numbers.into_iter() {
        println!("拥有: {}", num);
    }
    // println!("{:?}", numbers); // 错误！已被移动
    
    // HashMap 与所有权
    let mut map = HashMap::new();
    
    let key1 = String::from("color");
    let value1 = String::from("red");
    
    map.insert(key1, value1); // 移动到 HashMap
    // println!("{}, {}", key1, value1); // 错误！已被移动
    
    // 使用 clone 保留原始值
    let key2 = String::from("size");
    let value2 = String::from("large");
    
    map.insert(key2.clone(), value2.clone()); // 克隆后插入
    println!("原始值仍可用: {}, {}", key2, value2);
    
    // 从 HashMap 获取值
    if let Some(color) = map.get("color") {
        println!("颜色: {}", color); // 借用
    }
    
    // 移动出 HashMap
    if let Some(size) = map.remove("size") {
        println!("移动的大小: {}", size);
    }
}
```

### 6.4 闭包与所有权

```rust
fn closures_ownership() {
    let x = String::from("hello");
    
    // 借用捕获
    let closure1 = || {
        println!("借用 x: {}", x); // 不可变借用
    };
    
    closure1();
    println!("x 仍然有效: {}", x);
    
    // 移动捕获
    let y = String::from("world");
    let closure2 = move || {
        println!("移动 y: {}", y); // 移动到闭包中
    };
    
    closure2();
    // println!("y: {}", y); // 错误！y 已被移动
    
    // 可变捕获
    let mut z = String::from("rust");
    {
        let mut closure3 = || {
            z.push('!'); // 可变借用
        };
        closure3();
    }
    println!("修改后的 z: {}", z);
    
    // 返回闭包
    fn make_adder(x: i32) -> impl Fn(i32) -> i32 {
        move |y| x + y // 必须使用 move
    }
    
    let add5 = make_adder(5);
    println!("5 + 3 = {}", add5(3));
    
    // 闭包作为参数
    fn apply_to_vec<F>(mut vec: Vec<i32>, f: F) -> Vec<i32>
    where
        F: Fn(&mut i32),
    {
        for item in vec.iter_mut() {
            f(item);
        }
        vec
    }
    
    let numbers = vec![1, 2, 3, 4, 5];
    let doubled = apply_to_vec(numbers, |x| *x *= 2);
    println!("翻倍后: {:?}", doubled);
}
```

### 6.5 线程与所有权

```rust
use std::thread;
use std::sync::{Arc, Mutex};

fn threads_ownership() {
    // 基本线程所有权
    let data = String::from("Hello from thread");
    
    let handle = thread::spawn(move || {
        println!("线程中: {}", data); // data 被移动到线程中
    });
    
    handle.join().unwrap();
    // println!("{}", data); // 错误！data 已被移动
    
    // 共享数据使用 Arc
    let shared_data = Arc::new(String::from("Shared data"));
    let mut handles = vec![];
    
    for i in 0..3 {
        let data_clone = Arc::clone(&shared_data);
        let handle = thread::spawn(move || {
            println!("线程 {} 看到: {}", i, data_clone);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    // 可变共享数据使用 Arc<Mutex<T>>
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("计数器结果: {}", *counter.lock().unwrap());
    
    // 通道与所有权
    use std::sync::mpsc;
    
    let (tx, rx) = mpsc::channel();
    
    thread::spawn(move || {
        let messages = vec![
            String::from("消息1"),
            String::from("消息2"),
            String::from("消息3"),
        ];
        
        for msg in messages {
            tx.send(msg).unwrap(); // 消息被移动到通道中
        }
    });
    
    for received in rx {
        println!("收到: {}", received);
    }
}
```

### 6.6 性能优化技巧

```rust
fn performance_tips() {
    // 技巧1：避免不必要的克隆
    fn bad_approach(strings: Vec<String>) -> Vec<String> {
        strings.into_iter()
            .map(|s| s.clone()) // 不必要的克隆
            .collect()
    }
    
    fn good_approach(strings: Vec<String>) -> Vec<String> {
        strings // 直接返回，利用移动语义
    }
    
    // 技巧2：使用 Cow (Clone on Write)
    use std::borrow::Cow;
    
    fn process_text(input: &str) -> Cow<str> {
        if input.contains("bad_word") {
            // 需要修改时才克隆
            Cow::Owned(input.replace("bad_word", "***"))
        } else {
            // 不需要修改，直接借用
            Cow::Borrowed(input)
        }
    }
    
    let clean_text = "This is clean";
    let dirty_text = "This contains bad_word";
    
    println!("处理干净文本: {}", process_text(clean_text));
    println!("处理脏文本: {}", process_text(dirty_text));
    
    // 技巧3：使用引用而不是所有权传递大对象
    #[derive(Clone)]
    struct LargeStruct {
        data: Vec<u8>,
    }
    
    impl LargeStruct {
        fn new() -> Self {
            LargeStruct {
                data: vec![0; 10000], // 大数据
            }
        }
    }
    
    // 不好：传递所有权
    fn process_large_bad(large: LargeStruct) -> usize {
        large.data.len()
    }
    
    // 好：传递引用
    fn process_large_good(large: &LargeStruct) -> usize {
        large.data.len()
    }
    
    let large = LargeStruct::new();
    println!("大结构体大小: {}", process_large_good(&large));
    println!("仍可使用: {}", large.data.len());
    
    // 技巧4：使用 into() 进行类型转换
    fn accept_string(s: String) {
        println!("接受字符串: {}", s);
    }
    
    fn flexible_accept(s: impl Into<String>) {
        let s = s.into();
        println!("灵活接受: {}", s);
    }
    
    accept_string("literal".to_string()); // 需要显式转换
    flexible_accept("literal"); // 自动转换
    flexible_accept(String::from("owned"));
}
```

### 6.7 常见陷阱和解决方案

```rust
fn common_pitfalls() {
    // 陷阱1：在循环中移动
    let strings = vec![
        String::from("hello"),
        String::from("world"),
        String::from("rust"),
    ];
    
    // 错误方式
    /*
    for s in strings {
        println!("{}", s);
        // strings 在第一次迭代后就失效了
    }
    */
    
    // 正确方式1：借用
    for s in &strings {
        println!("借用: {}", s);
    }
    
    // 正确方式2：消费（如果不需要再使用）
    for s in strings.into_iter() {
        println!("消费: {}", s);
    }
    
    // 陷阱2：部分移动后的结构体
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u32,
    }
    
    let person = Person {
        name: String::from("Alice"),
        age: 30,
    };
    
    let name = person.name; // 部分移动
    // println!("{:?}", person); // 错误！
    
    // 解决方案：克隆或重新构造
    let person2 = Person {
        name: String::from("Bob"),
        age: 25,
    };
    
    let name2 = person2.name.clone(); // 克隆而不移动
    println!("人员: {:?}", person2); // 仍然有效
    println!("克隆的名字: {}", name2);
    
    // 陷阱3：可变引用的作用域
    let mut s = String::from("hello");
    
    // 错误的做法
    /*
    let r1 = &mut s;
    let r2 = &mut s; // 错误！
    println!("{}, {}", r1, r2);
    */
    
    // 正确的做法：分开作用域
    {
        let r1 = &mut s;
        r1.push_str(" world");
    } // r1 在这里离开作用域
    
    let r2 = &mut s;
    r2.push('!');
    
    println!("最终字符串: {}", s);
    
    // 陷阱4：迭代器消费
    let numbers = vec![1, 2, 3, 4, 5];
    
    // 错误：多次使用消费性迭代器
    /*
    let iter = numbers.into_iter();
    let sum: i32 = iter.sum();
    let count = iter.count(); // 错误！iter 已被消费
    */
    
    // 正确：分别处理或使用非消费性方法
    let sum: i32 = numbers.iter().sum();
    let count = numbers.len();
    
    println!("和: {}, 数量: {}", sum, count);
    println!("原始向量: {:?}", numbers); // 仍然有效
}
```

### 6.8 最佳实践总结

```rust
fn best_practices() {
    // 1. 优先使用借用而不是所有权
    fn analyze_text(text: &str) -> (usize, usize) {
        (text.len(), text.chars().count())
    }
    
    // 2. 返回所有权而不是借用（避免生命周期复杂性）
    fn create_greeting(name: &str) -> String {
        format!("Hello, {}!", name)
    }
    
    // 3. 使用 impl Trait 提供灵活性
    fn process_items<T>(items: impl IntoIterator<Item = T>) 
    where 
        T: std::fmt::Display,
    {
        for item in items {
            println!("处理项目: {}", item);
        }
    }
    
    // 4. 合理使用 Clone
    #[derive(Clone, Debug)]
    struct Config {
        name: String,
        value: i32,
    }
    
    fn use_config(config: Config) {
        println!("使用配置: {:?}", config);
    }
    
    let config = Config {
        name: String::from("debug"),
        value: 1,
    };
    
    // 如果后续还需要 config，则克隆
    use_config(config.clone());
    println!("原配置: {:?}", config);
    
    // 5. 函数设计原则
    
    // 好的 API 设计：接受借用，返回拥有
    fn good_api(input: &str) -> String {
        input.to_uppercase()
    }
    
    // 灵活的 API：使用泛型约束
    fn flexible_api<S: AsRef<str>>(input: S) -> String {
        input.as_ref().to_lowercase()
    }
    
    let text = String::from("Hello World");
    println!("好的 API: {}", good_api(&text));
    println!("灵活 API: {}", flexible_api(&text));
    println!("原文本: {}", text); // 仍然可用
    
    // 6. 错误处理最佳实践
    use std::fs;
    use std::io;
    
    // 返回拥有的错误信息
    fn read_and_process(filename: &str) -> Result<String, String> {
        let content = fs::read_to_string(filename)
            .map_err(|e| format!("无法读取文件 {}: {}", filename, e))?;
        
        if content.is_empty() {
            Err("文件为空".to_string())
        } else {
            Ok(content.trim().to_string())
        }
    }
    
    // 使用示例
    match read_and_process("example.txt") {
        Ok(content) => println!("文件内容: {}", content),
        Err(error) => println!("错误: {}", error),
    }
    
    println!("\n=== 最佳实践要点 ===");
    println!("1. 函数参数优先使用借用 (&T)");
    println!("2. 函数返回值优先返回所有权 (T)");
    println!("3. 避免不必要的 clone()");
    println!("4. 使用 impl Trait 提供 API 灵活性");
    println!("5. 理解移动语义，合理设计数据流");
    println!("6. 在多线程中使用 Arc<T> 和 Arc<Mutex<T>>");
    println!("7. 优先使用迭代器而不是索引访问");
    println!("8. 合理使用生命周期注解，但不要过度使用");
}

fn main() {
    println!("=== Rust 所有权、移动和引用教程 ===\n");
    
    // 1. 所有权基础
    println!("1. 所有权基础概念:");
    stack_vs_heap();
    copy_vs_drop();
    ownership_transfer();
    
    // 2. 移动语义
    println!("\n2. 移动语义详解:");
    move_semantics_explained();
    clone_vs_move();
    partial_move();
    collection_moves();
    
    // 3. 引用和借用
    println!("\n3. 引用和借用:");
    immutable_references();
    mutable_references();
    reference_rules();
    dangling_references();
    dereferencing();
    
    // 4. 生命周期
    println!("\n4. 生命周期:");
    lifetime_basics();
    lifetime_in_functions();
    lifetime_in_structs();
    lifetime_elision_rules();
    static_lifetime();
    
    // 5. 智能指针
    println!("\n5. 智能指针:");
    box_pointer();
    reference_counting();
    interior_mutability();
    
    // 6. 实战示例
    println!("\n6. 实战示例和最佳实践:");
    ownership_patterns();
    error_handling_ownership();
    collections_ownership();
    closures_ownership();
    threads_ownership();
    performance_tips();
    common_pitfalls();
    best_practices();
    
    println!("\n=== 教程结束 ===");
}